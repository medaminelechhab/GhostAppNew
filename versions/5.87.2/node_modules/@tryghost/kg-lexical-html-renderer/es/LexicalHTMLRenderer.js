import { createHeadlessEditor } from '@lexical/headless';
import { ListItemNode, ListNode } from '@lexical/list';
import { HeadingNode, QuoteNode } from '@lexical/rich-text';
import { LinkNode } from '@lexical/link';
import $convertToHtmlString from './convert-to-html-string';
import getDynamicDataNodes from './get-dynamic-data-nodes';
// TODO: Using import causes circular definitions for kg-default-nodes
// eslint-disable-next-line @typescript-eslint/no-var-requires
const { registerRemoveAtLinkNodesTransform } = require('@tryghost/kg-default-transforms');
/* c8 ignore next 3 */
function defaultOnError() {
    // do nothing
}
export default class LexicalHTMLRenderer {
    dom;
    nodes;
    onError;
    constructor({ dom, nodes, onError } = {}) {
        if (!dom) {
            // eslint-disable-next-line @typescript-eslint/no-var-requires
            const jsdom = require('jsdom');
            const { JSDOM } = jsdom;
            this.dom = new JSDOM();
        }
        else {
            this.dom = dom;
        }
        this.nodes = nodes || [];
        this.onError = onError || defaultOnError;
    }
    async render(lexicalState, userOptions = {}) {
        const defaultOptions = {
            target: 'html',
            dom: this.dom
        };
        const options = Object.assign({}, defaultOptions, userOptions);
        const DEFAULT_NODES = [
            HeadingNode,
            ListNode,
            ListItemNode,
            QuoteNode,
            LinkNode,
            ...this.nodes
        ];
        const editor = createHeadlessEditor({
            nodes: DEFAULT_NODES,
            onError: this.onError
        });
        const editorState = editor.parseEditorState(lexicalState);
        // gather nodes that require dynamic data
        const dynamicDataNodes = getDynamicDataNodes(editorState);
        // fetch dynamic data
        const renderData = new Map();
        await Promise.all(dynamicDataNodes.map(async (node) => {
            if (!node.getDynamicData) {
                return;
            }
            const { key, data } = await node.getDynamicData(options);
            renderData.set(key, data);
        }));
        options.renderData = renderData;
        // set up editor with our state
        editor.setEditorState(editorState);
        // register transforms that clean up state for rendering
        registerRemoveAtLinkNodesTransform(editor);
        // render
        let html = '';
        editor.update(async () => {
            html = $convertToHtmlString(options);
        });
        return html;
    }
}
//# sourceMappingURL=LexicalHTMLRenderer.js.map